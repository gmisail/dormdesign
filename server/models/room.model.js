// const rethinkdb = require("rethinkdb");
const Database = require("../db");
const { v4: uuidv4 } = require("uuid");
const Template = require("./template.model");
const Cache = require("../cache");
const { client } = require("../cache");
const Item = require("./item.model");

const { updateRoomPropertySchema } = require("../schemas/room.schema");

const Joi = require("joi");
const { validateWithSchema } = require("../utils.js");

const DEBUG_MESSAGES = Boolean(process.env.DEBUG_MESSAGES ?? "false");

let Room = {};
Room.MAX_NAME_LENGTH = 40;

/**
 * Create a new room with a given name
 * @param { string } name
 * @returns { Promise.<object> } The newly created room object
 * @throws When the creation fails
 */
Room.create = async function (name) {
  let vertices = [
    { x: -5, y: -5 },
    { x: 5, y: -5 },
    { x: 5, y: 5 },
    { x: -5, y: 5 },
  ];

  const id = uuidv4();
  const template = await Template.create(id);

  const room = {
    name,
    items: [],
    templateId: template.id,
    vertices,
  };

  try {
    await Database.client
      .db("dd_data")
      .collection("rooms")
      .insertOne({ ...room, _id: id });
  } catch (err) {
    throw new Error("Failed to create room: " + err);
  }

  if (DEBUG_MESSAGES) console.log(`Room ${id} has been created.`);

  return { ...room, id: id };
};

/**
 * Deletes the room with the given id.
 * @param { string } id
 * @returns { Promise.<object> }
 * @throws When the delete fails
 */
Room.delete = async function (id) {
  try {
    await Database.client.db("dd_data").collection("rooms").deleteOne({ _id: id });
    if (DEBUG_MESSAGES) console.log(`Room ${id} has been deleted from the database`);
  } catch (err) {
    throw new Error(`Failed to delete room ${id} ` + err);
  }

  await Cache.client.del(id);

  if (DEBUG_MESSAGES) console.log(`Room ${id} has been removed from the cache.`);
};

/**
 * Get the JSON data from a room at an ID. Returns the cached version if it exists, the version in the database otherwise.
 * @param { string } id
 * @returns { Promise.<object> } The room object if it exists
 * @throws When the function fails to get the room
 */
Room.get = async function (id) {
  // First check if room is in the cache
  let room = await client.get(id);
  if (room !== null) {
    return JSON.parse(room);
  }

  /* Since it is not cached, retrieve it from the database and store it in the cache. */
  try {
    room = await Database.client.db("dd_data").collection("rooms").findOne({ _id: id });
  } catch (err) {
    throw new Error(`Failed to get room with id ${id}.` + err);
  }

  if (room === null) {
    const err = new Error(`Room with id ${id} not found`);
    err.status = 404;
    throw err;
  }

  room.id = room._id;
  delete room["_id"];

  const res = await Cache.client.set(id, JSON.stringify(room));
  if (res === "OK" && DEBUG_MESSAGES) {
    console.log(`Added room ${id} to the cache.`);
  }

  return room;
};

/**
 * Copy data from template with ID templateId into room with ID id
 * @param { string } id
 * @param { string } templateId
 * @returns { Promise.<object> }
 * @throws If either room at 'id' or the template at 'templateId' fail to be fetched
 */
Room.copyFrom = async function (id, templateId) {
  const room = await Room.get(id);
  const template = await Template.get(templateId);
  const templateData = await Room.get(template.targetId);

  templateData.id = room.id;
  templateData.templateId = room.templateId;
  templateData.name = room.name;

  await Cache.client.set(id, JSON.stringify(templateData));

  return templateData;
};

/**
 * Updates the fields in the room with given 'id' from the corresponding fields in 'update'. If any of the fields in the update
 * don't exist in the room, the entire update fails.
 * @param { string } id The ID of the room to update
 * @param { JSON } update The update
 * @throws When 'update' contains a field that can't be updated in the room
 */
Room.updateProperties = async function (id, update) {
  let room = await Room.get(id);
  validateWithSchema(update, updateRoomPropertySchema);
  Object.assign(room, update);

  await Cache.client.set(id, JSON.stringify(room));
};

/**
 * Update the vertices of a given room
 * @param { string } id
 * @param { array[{ x: number, y: number }] } vertices
 * @throws An error if the update fails
 */
Room.updateVertices = async function (id, vertices) {
  await Room.updateProperties(id, { vertices });
};

/**
 * Update the name of a given room
 * @param { string } id
 * @param { string } name
 * @throws An error if the update fails
 */
Room.updateRoomName = async function (id, name) {
  await Room.updateProperties(id, { name });
};

/**
 * Add an item (generated by the Item model schema) to a given room
 * @param { string } id
 * @param { JSON } item
 * @returns { Promise.<object> } the new item
 * @throws When creating the item or adding it to the room fails
 */
Room.addItem = async function (id, item) {
  const newItem = Item.create(item);
  const room = await Room.get(id);

  let items = room.items;
  items.push(newItem);

  await Cache.client.set(id, JSON.stringify(room));

  return newItem;
};

/**
 * Clear the items of a given room
 * @param { string } id
 * @throws When there's an error getting the room with 'id' (e.g. the room doesn't exist)
 */
Room.clearItems = async function (id) {
  const room = await Room.get(id);
  room.items = [];

  await Cache.client.set(id, JSON.stringify(room));
};

/**
 * Clear all of the items in a room
 * @param { string } id
 * @throws When there's an error getting the room with 'id' (e.g. the room doesn't exist)
 */
Room.removeItem = async function (id, itemId) {
  const room = await Room.get(id);

  room.items = room.items.filter((item) => item._id !== itemId);

  await Cache.client.set(id, JSON.stringify(room));
};

/**
 * Edit the properties multiple items in a room. If any of the updates fail, none of the updates are applied
 * @param { string } id
 * @param { object } updates Object containg updates to items. Should be of the form [{ id, update }]
 * @throws When there's an error getting the room or one of the updates fails
 */
Room.updateItems = async function (id, updates) {
  let room = await Room.get(id);

  let updateMap = {};
  for (let i = 0; i < updates.length; i++) {
    updateMap[updates[i].id] = updates[i].updated;
  }
  for (let i = 0; i < room.items.length; i++) {
    let item = room.items[i];
    const update = updateMap[item.id];
    if (update !== undefined) {
      Item.update(item, update);
    }
  }

  Cache.client.set(id, JSON.stringify(room));
};

/** Updates the database with the content that is currently in the cache.
 * @param { string } id
 * @returns false if the room isn't in the cache and true if the save succeeds
 * @throws When there's an error updating the room in the cache to the room in the database
 */
Room.save = async function (id) {
  let room = await client.get(id);
  if (room !== null) {
    room = JSON.parse(room);
  } else {
    // This could occur if the room was just fully deleted
    if (DEBUG_MESSAGES)
      console.log(
        "Cannot push room from cache to database " + id + ". The room doesn't exist in the cache"
      );
    return false;
  }

  try {
    await Database.client.db("dd_data").collection("rooms").replaceOne({ _id: id }, room);
  } catch (err) {
    throw new Error(`Failed to save room ${id} from cache to db: ` + err);
  }

  if (DEBUG_MESSAGES) console.log("Room " + id + " pushed from cache to database.");

  return true;
};

module.exports = Room;
