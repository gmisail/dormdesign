// const rethinkdb = require("rethinkdb");
const Database = require("../db");
const { v4: uuidv4 } = require("uuid");
const Template = require("./template.model");
const Cache = require("../cache");
const { client } = require("../cache");

let Room = {};
Room.MAX_NAME_LENGTH = 20;

/**
 * Create a new room with a given name
 * @param { string } name
 * @returns { Promise.<object> } room object if it exists, null otherwise
 */
Room.create = async function (name) {
  let vertices = [
    { x: -5, y: -5 },
    { x: 5, y: -5 },
    { x: 5, y: 5 },
    { x: -5, y: 5 },
  ];

  const id = uuidv4();
  const templateId = await Template.create(id);

  // Don't include id yet since we'll need to use the '_id' field when inserting into mongo
  const room = {
    name,
    items: [],
    templateId,
    vertices,
  };

  try {
    await Database.client
      .db("dd_data")
      .collection("rooms")
      .insertOne({ _id: id, ...room });
  } catch (err) {
    throw new Error("Failed to create room: " + err);
  }

  console.log(`Room ${id} has been created.`);

  return { id: id, ...room };
};

Room.delete = async function (id) {
  try {
    await Database.client.db("dd_data").collection("rooms").deleteOne({ _id: id });
    console.log(`Room ${id} has been deleted from the database`);
  } catch (err) {
    throw new Error(`Failed to delete room ${id} ` + err);
  }

  Cache.client.del(id).then((_) => console.log(`Room ${id} has been removed from the cache.`));
};

/**
 * Get the JSON data from a room at an ID. Returns the cached version if it exists, the version in the database otherwise.
 * @param { string } id
 * @returns { Promise.<object> } room object if it exists, null otherwise
 */
Room.get = async function (id) {
  // First check if room is in the cache
  let room = await client.get(id);
  if (room !== null) {
    return JSON.parse(room);
  }

  /* Since it is not cached, retrieve it from the database and store it in the cache. */
  try {
    room = await Database.client.db("dd_data").collection("rooms").findOne({ _id: id });
  } catch (err) {
    throw new Error(`Failed to get room ${id}: ` + err);
  }

  const res = await Cache.client.set(id, JSON.stringify(room));
  if (res === "OK") {
    console.log(`Added room ${id} to the cache.`);
  }

  return room;
};

/**
 * Copy data from templateId into room with ID id
 * @param { string } id
 * @param { string } templateId
 * @returns { Promise.<object> } null if there is an error, returns new data otherwise
 */
Room.copyFrom = async function (id, templateId) {
  const room = await Room.get(id);
  const template = await Template.get(templateId);
  const templateData = await Room.get(template.targetId);

  templateData.id = room.id;
  templateData.templateId = room.templateId;
  templateData.name = room.name;

  try {
    await Room.updateProperty(id, templateData);
  } catch (error) {
    console.error("Could not copy room " + templateId + " to " + id);
    throw error;
  }

  return templateData;
};

/**
 * Updates the given property in a room.
 * @param { string } id
 * @param { JSON } data
 * @returns { Promise.<boolean> } true if there is an error, false otherwise
 */
Room.updateProperty = async function (id, data) {
  let room = await Room.get(id);

  for (const [key, value] of Object.entries(data)) {
    if (room.hasOwnProperty(key)) {
      room[key] = data[key];
    }
  }

  await Cache.client.set(id, JSON.stringify(room));

  return false;
};

/**
 * Update the vertices of a given room
 * @param { string } id
 * @param { array[{ x: number, y: number }] } vertices
 * @returns { Promise.<boolean> } true if there is an error, false otherwise
 */
Room.updateVertices = async function (id, vertices) {
  try {
    let res = await Room.updateProperty(id, { vertices });

    return res;
  } catch (error) {
    throw error;
  }
};

/**
 * Update the name of a given room
 * @param { string } id
 * @param { string } name
 * @returns { Promise.<boolean> } true if there is an error, false otherwise
 */
Room.updateRoomName = async function (id, name) {
  try {
    let res = await Room.updateProperty(id, { name });

    return res;
  } catch (error) {
    throw error;
  }
};

/**
 * Change the nickname of a currently active user
 * @param { string } id
 * @param { string } userId
 * @param { string} name
 */
Room.updateNickname = async function (id, userId, name) {};

/**
 * Add an item (generated by the Item model schema) to a given room
 * @param { string } id
 * @param { JSON } item
 * @returns { Promise.<object> } null if there is an error, otherwise returns the new Item
 */
Room.addItem = async function (id, item) {
  const itemId = uuidv4();

  let room = await Room.get(id);

  // construct the new array of items (if one exists)
  let items = room.items || [];
  item.id = itemId;
  items.push(item);

  try {
    await Room.updateProperty(id, { items });
  } catch (error) {
    throw error;
  }

  return item;
};

/**
 * Clear the items of a given room
 * @param { string } id
 * @returns { Promise.<boolean> } true if there is an error, false otherwise
 */
Room.clearItems = async function (id) {
  try {
    await Room.updateProperty(id, { items: [] });
  } catch (error) {
    throw error;
  }

  return false;
};

/**
 * Clear all of the items in a room
 * @param { string } id
 * @returns { Promise.<boolean> } true if there is an error, false otherwise
 */
Room.removeItem = async function (id, itemID) {
  try {
    let room = await Room.get(id);
    let items = room.items || [];
    items = items.filter((item) => item.id !== itemID);

    await Room.updateProperty(id, { items });

    return true;
  } catch (error) {
    const err = "Failed to remove item " + itemId + " from room " + id + ". " + error;

    console.error(err);
    throw new Error(err);
  }
};

/**
 * Edit the properties of a single item in a room
 * @param { string } id
 * @param { string } itemId
 * @param { object } properties
 * @returns { Promise.<boolean> } true if there is an error, false otherwise
 */
Room.updateItem = async function (id, itemId, properties) {
  try {
    let room = await Room.get(id);

    for (let item in room) {
      if (room[item].id === itemId) {
        room[item] = Object.assign(properties, room[item]);
      }
    }

    await Cache.client.set(id, JSON.stringify(room));

    return false;
  } catch (error) {
    const err = "Failed to update item " + itemId + " in room " + id;

    console.error(err);
    throw new Error(err);
  }
};

/**
 * Edit the properties multiple items in a room
 * @param { string } id
 * @param { object } updates Object containg updates to items. Should be of the form { itemID : updates }
 * @returns { Promise.<boolean> } true if there is an error, false otherwise
 */
Room.updateItems = async function (id, updates) {
  try {
    let room = await Room.get(id);

    for (let item in room.items) {
      if (room.items[item].id in updates) {
        room.items[item] = Object.assign(room.items[item], updates[room.items[item].id]);
      }
    }

    Cache.client.set(id, JSON.stringify(room));

    return false;
  } catch (error) {
    const err =
      "Failed to complete item updates " +
      JSON.stringify(updates) +
      " in room " +
      id +
      ". " +
      error;

    console.error(err);
    throw new Error(err);
  }
};

/* Updates the database with the content that is currently in the cache.
 * @param { string } id
 * */
Room.save = async function (id) {
  let room = await client.get(id);
  if (room !== null) {
    room = JSON.parse(room);
  } else {
    // This could occur if the room was just fully deleted
    console.log(
      "Cannot push room from cache to database " + id + ". The room doesn't exist in the cache"
    );
    return;
  }

  try {
    await Database.client.db("dd_data").collection("rooms").replaceOne({ _id: id }, room);
  } catch (err) {
    throw new Error("Failed to save room from cache to db: " + err);
  }

  console.log("Room " + id + " pushed from cache to database.");
};

module.exports = Room;
